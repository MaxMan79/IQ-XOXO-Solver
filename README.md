# IQ-XOXO-Solver
Solves the IQ XOXO ™ Puzzle from Smart Games ®

My kids got one of these puzzles for Christmas, and we have had fun solving it together.  I had some unexpected time off from work and decided to try to work out an algorithm to solve it and also to generate more examples.  The code here is what I accomplished during those few days.  I had hoped to get a WPF GUI completed, but the solver ended up taking longer than expected.  Unfortunately, I probably will not get around to adding a GUI any time soon, or maybe not at all.  The solver, however, works.  The performance is not where I would like for the most difficult examples (like where you start off with only a single game piece on the board).  I opted for a brute-force, recursive search for solutions, with some simple early-outs.  

To improve the performance for the more difficult examples, I first introduced the concept of Flood Zones, where a Flood Zone is simply  any contiguous group of unoccupied cells.  Sometimes the board can get split such there are multiples of such empty cell groups.  It is  faster to finish trying to solve one Flood Zone at a time, rather than bouncing back and forth between Flood Zones.

To improve the performance once again, I introduced the concept of Importance Maps, where cells are assigned an importance value based on how many of their neighbors are occupied.  This is analogous to an occlusion test.  As cells become more occluded, they start to raise their neighbors' importance as well.  With this approach, cells that are located in "tight spaces" have a higher importance and the solver will try to place pieces on these cells first.  The idea is that when cells are highly occluded there are fewer potential pieces that can fit on them, leading the solver to find the correct piece more quickly.

To improve the performance one last time, I introduced the concept of Abandonment, which is just a maximum search depth into the solution tree after which a branch is abandoned.  Once the max search depth is reached without finding a solution, the solver "unwinds" the board back to the starting configuration and continues the search using the next game piece.  If the real solution existed down that branch somewhere beyond the max search depth, then the solve will eventually fail, but it could take a while.  You can use whatever value you want for the max search depth... a good balance of "performance" vs. "searching deep enough to find a solution" seems to be 4 raised to the power of the number of pieces not on the board in the starting configuration.  If you know there is a valid solution, however, and the solver is failing to find it, the first thing I would suggest is increasing AutoSolver._max_leaf_count.

Since there is no GUI at the moment, you will have to either write the result out (i.e. to the console or to a file) or put a break point in the code to examine the results from within a debug session.  Or if you know WPF, you could flesh out the GUI for your needs.  The code where you will want to start is located in IQ-XOXO-Solver/IQ-XOXO-Solver/ViewModels/MainWindowViewModel.cs.  There you can see how the code is to be used from a high level.

If I had the time (or if this was more than just a little personal project), I would improve the solver in one of two ways:

1) Change from a brute-force search to a neural network approach (AI)
2) Move the brute-force algorithm over to the GPU, using either CUDA or the DirectX pipeline
